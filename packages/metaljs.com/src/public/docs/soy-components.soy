{namespace docsSoyComponents}

/**
 * This template will be rendered by SoyWeb when the user loads static.soy.
 * It deliberately includes dummy data so the designer can get a feel for how
 * the task list will appear with real data rather with minimal copy and paste.
 */
{template .soyweb}
{call docs.layout}
	{param content kind="html"}
		<h1>Soy Components</h1>

		<p>This section will explain how to build rich widgets on Metal.js, by taking advantage of the built-in <a href="http://developers.google.com/closure/templates">soy templates</a> integration, enabling you to easily separate business logic from rendering logic.</p>

		<p>So, for example, let's say we want to create a component called <strong>MyComponent</strong>, that has a body and a footer with content. The soy file would look like this:</p>

		{call .soyExample /}

		{call .jsExample /}

		{call .runExample /}
	{/param}
{/call}
{/template}

/**
 * Example for the JS part of a soy component.
 */
{template .jsExample}
	<p>Since all that rendering logic is done automatically for you just from creating a soy file, you don't actually need a JS file at all if that's all the component needs to do. When compiled, the soy file will already generate the appropriate component class for you.</p>

	<p>Many components do need more behavior though, so to add more JS to a soy component you should have a JS file like this:</p>

	<textarea class="code" data-mode="javascript">{literal}
import templates from './MyComponent.soy';
import Component from 'metal-component';
import Soy from 'metal-soy';

class MyComponent extends Component {
}
Soy.register(MyComponent, templates);

export default MyComponent;{/literal}</textarea>

	<p>It basically just defines a class named <b>MyComponent</b> that extends Metal.js's <b>Component</b> class, and registers its soy templates (which are automatically exported from the soy file).</p>

	<p>There are many ways to add behavior to your component. You can add handlers for <a href="/docs/inline-events.html">inline listeners</a>, add <a href="/docs/state.html">state configuration</a> or simply override <a href="/docs/component-lifecycle.html">lifecycle functions</a> to add any other logic you need.</p>
{/template}

/**
 * Example for the template part of a soy component.
 */
{template .soyExample}
	<textarea class="code" data-mode="x-soy">{literal}
&lbrace;namespace MyComponent&rbrace;

/**
* This renders the component's whole content.
*/
&lbrace;template .render&rbrace;
  &lbrace;@param bodyContent: html&rbrace;
  &lbrace;@param footerContent: html&rbrace;
  &lt;p&gt;&lbrace;$bodyContent&rbrace;&lt;/p&gt;
  &lt;footer&gt;&lbrace;$footerContent&rbrace;&lt;/footer&gt;
&lbrace;/template&rbrace;{/literal}</textarea>

	<p>Looking at that you can see that it's just a basic soy file. Now let's understand how this integration with the template works.</p>

	<p>Firstly, Metal.js will by default use the template named `render` as the component's content. You can have other templates in youy soy file, but the `render` template should be the main one.</p>

	<p>Secondly, each param used on this main template will be automatically added to the component's <a href="/docs/state.html">state</a>. This basically means that Metal.js will set these params as properties of the component, as well as track any changes to them, automatically rerendering the component when necessary. In <b>MyComponent</b>'s case this means that whenever the value of the <code>bodyContent</code> param is changed, that part of the component that uses it will be updated, even though there is no JavaScript code on MyComponent to handle this logic. The same goes for the <code>footerContent</code> param.</p>

	<p>Metal.js's logic for updating the component's contents automatically is very smart, it uses <a href="http://google.github.io/incremental-dom">incremental-dom</a>, so it will only rerender the parts of the component that actually changed.</p>
{/template}

/**
 * Example for running a soy component.
 */
{template .runExample}
	<p>Finally, to render an instance of MyComponent, just call <code>render</code>, passing any attribute values that you want to initialize:</p>

	<textarea class="code" data-mode="javascript">{literal}
new MyComponent({
	bodyContent: 'My Body',
	footerContent: '&lt;footer&gt;My Footer.&lt;/footer&gt;'
}).render(parentElement);{/literal}</textarea>
{/template}
