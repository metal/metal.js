{"title":"Metal.js","githubRepo":"metal/metaljs.com","googleAnalytics":"UA-37033501-7","index":{"title":"Metal.js","description":"Build UI components in a solid, flexible way.","content":" Brought to you by Liferay, Inc. © 2017. Powered by WeDeploy™ ","srcFilePath":"src/pages/index.soy","id":"pages","location":"/./","url":"/./","children":{"docs":{"title":"Documentation","description":"Everything you need to know to get started.","content":" Docs Start learning how to leverage the power of . Get started right away with Tutorals, or dig into the details with Guides. Each guide provides step by step coverage for that core feature. ","srcFilePath":"src/pages/docs/index.soy","id":"docs","location":"/docs/","url":"/docs/","children":{"search":{"title":"Search","description":"Find what you're looking for in the documentation.","hidden":true,"content":" Electric Docs Start learning how to leverage the power of . ","srcFilePath":"src/pages/docs/search.soy","id":"search","location":"/docs/search.html","url":"/docs/search.html"},"guides":{"children":{"alias":{"title":"Alias","description":"","layout":"guide","weight":100,"content":" Alias A straightforward way to import npm dependencies into your module is to use their relative paths, like we do for any other code. For example: import core from '../node_modules/metal/src/core'; Having to supply the relative path to node_modules is not cool though and, besides that, it may cause problems when a module doing that is imported later as an npm dependency of another project, since the paths will change. Knowing that, Metal.js allows importing npm dependencies like you would from a regular node module, just by referencing their names. Note that this will only work when using Metal.js's build tools or adding a similar logic to your build process yourself (though we provide a {sp}babel preset with this logic that you can use separately too). With aliases, the previous example can be rewritten like this: import core from 'metal'; ","srcFilePath":"src/pages/docs/guides/alias.md","id":"alias","location":"/docs/guides/alias.html","url":"/docs/guides/alias.html"},"building":{"title":"Building","description":"","layout":"guide","weight":220,"content":" As we mentioned before, Metal.js components are written in ES6, which means that we need a transpiling process before using it on a website. This can be done via any tools that you prefer, like {sp}webpack or browserify, but we've also published a few tools of our own, which focuses on Metal.js{sp} projects, which we'll talk about here. metal-tools-soy This tool is required when building Metal.js components that use Soy. It takes the .soy files in your project and transpiles them to JavaScript that can then be imported in your component js files. It's suggested to run this tool as a CLI, but it can also be run programmatically if necessary. Take a look at the project's documentation for more information. If you are using webpack to bundle your Metal.js components, you can optionally use the metal-soy-loader which conveniently wraps metal-tools-soy for use with webpack. babel-preset-metal-jsx When building Metal.js JSX components, it is necessary to transpile the JSX to JavaScript. The babel-preset-metal-jsx package takes care of importing the necessary babel plugins that allow for this transpilation. Examples To see examples of these tools in action, check out the Yeoman Generator. The boilerplate it generates for both Soy and JSX components implement these tools out of the box. ","srcFilePath":"src/pages/docs/guides/building.md","id":"building","location":"/docs/guides/building.html","url":"/docs/guides/building.html"},"component-lifecycle":{"title":"Component Lifecycle","description":"","layout":"guide","weight":130,"content":" Component Lifecycle You can take advantage of several lifecycle methods that Metal.js components provide. The example below lists the available lifecycle methods in the order in which they're called: class MyComponent extends Component { /** Called when the component is first created, but before it's first rendered. */ created() { } /** Called when the component is rendered. @param {boolean} firstRender Flag indicating if this is the component's first render. */ rendered(firstRender) { } /** Called just before the component attaches to the DOM. */ willAttach() { } /** Called when the component is attached to the DOM. The component automatically attaches when it is first rendered, but it can also be attached (without rerendering the component) by calling the attach method directly. This is a good place to attach event listeners, since the component is available in the page. */ attached() { } /** Only applicable for Soy components. * Called just before state data is passed to the component's renderer. @param {!object} changes object literal with info on state changes. */ willReceiveState(changes) { } /** Only applicable for JSX components. * Called just before props data is passed to the component's renderer. @param {!object} propsChanges object literal with info on props changes. */ willReceiveProps(propsChanges) { } /** Called just before the renderer is about to rerender the component. If it returns false it will not rerender. @param {!object} changes object literal with info on state changes. @param {?object} propsChanges object literal with info on props changes. Note: propsChanges is only applicable for JSX components. */ shouldUpdate(changes, propsChanges) { return true; } /** Called just before the component rerenders. @param {!object} changes object literal with info on state changes. @param {?object} propsChanges object literal with info on props changes. Note: propsChanges is only applicable for JSX components. */ willUpdate(changes, propsChanges) { } /** Called just before the component detaches from the DOM. */ willDetach() { } /** Called when the component is detached from the DOM. The component is automatically detached when disposed, but it can also be detached (without disposing the component) by calling the detach method directly. This is a good place to detach event listeners, since the component is not available in the page anymore. */ detached() { } /** Called when the component is disposed. This should contain any necessary cleanup, like detaching any remaining events and disposing of sub components and local variables. */ disposed() { } /** Called just before the component renders. This takes the component state as an argument and lets you massage the data before it is passed down to the template. This is only applicable for Soy Components. */ prepareStateForRender(states) { return Object.assign({}, states); } } willReceiveState - Soy The willReceiveState lifecycle method lets you hook into the Soy component's state lifecycle. See the example component below: import Component from 'metal-component'; import Soy from 'metal-soy'; import templates from './MySoyComponent.soy'; class MySoyComponent extends Component { willReceiveState(changes) { if (changes.foo && changes.foo.newVal !== changes.foo.prevVal) { // This is available in the next render this.bar = 'bar1'; } } } MySoyComponent.STATE = { foo: { value: 'foo' }, bar: { value: 'bar' } }; Soy.register(MySoyComponent, templates); export default MySoyComponent; &#123;namespace MySoyComponent&#125; /** */ &#123;template. render&#125; {@param foo: string} {@param bar: string} {$foo}:{$bar} &#123;/template&#125; If we render this component and change the value of the foo state, the willReceiveState method fires before the component renders, which lets us set state values to pass to the next render. import MySoyComponent from './MySoyComponent'; const component = new MySoyComponnet(); component.foo = 'foo1'; component.once('rendered', function() { console.log(component.element.innerHTML); // component.element.innerHTML === 'foo1:bar1'; }); willReceiveProps - JSX The willReceiveProps lifecycle method lets you hook into the props lifecycle of JSX components. Let's take the following JSX component for example: import JSXComponent from 'metal-jsx'; class MyJSXComponent extends JSXComponent { render() { return {this.props.foo}:{this.state.bar} } willReceiveProps(changes) { if (changes.foo && changes.foo.newVal !== changes.foo.prevVal) { // This is available in the next render this.state.bar = 'bar1'; } } } MyJSXComponent.STATE = { bar: { value: 'bar' } }; MyJSXComponent.PROPS = { foo: { value: 'foo' } }; export default MyJSXComponent; If we render this component and change the value of the foo prop, the willReceiveProps method fires before the component renders, which lets us set the value of internal state values to pass to the next render: import MyJSXComponent from './MyJSXComponent'; const component = new MyJSXComponent(); component.props.foo = 'foo1'; component.once('rendered', function() { console.log(component.element.innerHTML); // component.element.innerHTML === 'foo1:bar1'; }); ","srcFilePath":"src/pages/docs/guides/component-lifecycle.md","id":"component-lifecycle","location":"/docs/guides/component-lifecycle.html","url":"/docs/guides/component-lifecycle.html"},"importing":{"title":"Importing a Third Party Component","description":"","layout":"guide","weight":170,"content":" There are now more libraries and frameworks available for front-end development than ever before. It's not uncommon to have five or more of these libraries involved in a single project. But keeping track of all these libraries and making sure they're up-to-date can be tricky. To solve this we can use npm, a package manager that makes it easy to manage all your application's dependencies. In this guide you are going to learn how to get up and running with npm. You'll start by installing the npm command-line utility and then go on to learn about the various commands that are available for managing Metal.js components. Lets get started! Installing Node.js/NPM If you don't already have Node.js or npm installed, head over to the {sp}Node.js website and download the relevant copy of Node.js for your system. The npm program is included with the install of Node.js. Now that you have npm installed, we can start looking at the commands that are used to manage packages. Finding components There are two different ways that you can find npm packages. Either using the online component directory, or using the command line utility. To search for packages on the command line you use the search command. This should be followed by your search query. npm search For example to search for packages that contain the word ‘metal’ you could do the following: npm search metal This command would return a whole bunch of results, with information about each matched module so you can pick the one you wish. Installing Components To add a new npm package to your project you use the install command. This should be passed the name of the package you wish to install. npm install In this example, we're going to install the metal-position component. npm install metal-position Installed packages will be placed in a node_modules directory. This is created in the folder which the bower program was executed. └── node_modules ├── metal ├── metal-position Importing a Component With the code already available, let's create a main.js file that will import the metal-position module. Note that we're using an {sp}alias to easily import npm files. import position from 'metal-position'; This means that you can now call any function from that module, in this example we'll get the viewport height. var viewportHeight = position.getClientHeight(window); console.log(viewportHeight); Metal.js components are written in ES6 (a.k.a ECMAScript 2015), so you can also use ES6 on your code like we did on the example. Since ES6 isn't fully implemented on browsers yet though, either a polyfill or a build process is necessary before using Metal on a website. ","srcFilePath":"src/pages/docs/guides/importing.md","id":"importing","location":"/docs/guides/importing.html","url":"/docs/guides/importing.html"},"inline-events":{"title":"Inline Events","description":"","layout":"guide","weight":150,"content":" Another feature Metal.js has that can be very useful is the ability to declare events inside templates, directly on the desired element. Besides being simple and intuitive, this feature allows Metal.js to handle attaching events itself, and so this can be done in the best way possible, with {sp}delegates for example, without the user having worry about that at all. These events are also automatically detached when the component is disposed. Inline Listeners - via Function Name You can add DOM event listeners easily through your templates, like this: The above code declares that whenever the *x* button is clicked, the {sp}close function from the component should be called. Inline Listeners - via Function Reference If you prefer though, you can also pass the actual function reference (instead of just its name) as an inline listener. // src/Modal.soy /** In the \"render\" template, soy params that match a component's function name will be that function (automatically bound to the component instance). */ &#123;template .render&#125; {@param close: any} // ... // ... &#123;/template} // src/Modal.js That will work exactly the same way as the previous example. Inline Listeners - Nested Components When using nested components it's also possible to inline events by using the events property: // src/Modal.soy {call Button.render} {param events: ['click': ['selector': 'button', 'fn': 'close']] /} {param label: 'Ok' /} {/call} // src/Modal.js var events = {click: { selector: 'button', fn: 'close' }}; This will cause the close function from the sub component to be called whenever a click event triggers for the elements that match the given selector. In case you want to listen to the event with a function from the parent component, just pass the function reference instead of a string, like this: // src/Modal.soy {call Button.render} {param events: ['click': ['selector': 'button', 'fn': $close]] /} {param label: 'Ok' /} {/call} // src/Modal.js var events = {click: { selector: 'button', fn: this.close.bind(this) }}; Besides DOM events, you can also listen to custom events from the sub component in this same way: // src/Modal.soy {call Button.render} {param events: ['labelChanged': $handleLabelChanged] /} {param label: 'Ok' /} {/call} // src/Modal.js var events = {labelChanged: this.handleLabelChanged.bind(this)}; Inline Listeners - Alternative Usage Besides the on[EventName] format you can also use data-on[eventname] for adding inline listeners. For example: Note that this format is supported mainly to enable doing {sp}progressive enhancement, when running Soy templates via Java for example. When templates using the {sp}on[EventName] format run in Java they will output elements with these as actual attributes, which can cause errors in the browser. In JavaScript these are used as element properties instead, so this problem doesn't occur. So feel free to use the format you like best, or that better fits your needs. ","srcFilePath":"src/pages/docs/guides/inline-events.md","id":"inline-events","location":"/docs/guides/inline-events.html","url":"/docs/guides/inline-events.html"},"isomorphic":{"title":"Isomorphic Rendering","description":"Server side rendering of Metal.js components.","layout":"guide","weight":240,"content":" Server Side Rendering In most cases Metal components will be rendered client side. Let's take the following component for example: import JSXComponent from 'metal-jsx'; class MyComponent extends JSXComponent { render() { return {this.props.message} } } MyComponent.PROPS = { message: { value: '' } }; export default MyComponent; After transpiling/bundling this component, it can be invoked in client side JavaScript: const component = new metal.MyComponent({ message: 'Hello, World!' }); // component.element.innerHTML === 'Hello, World!' Rendering a component this way requires DOM manipulation, and the existence of various global variables/utilities that are provided by web browsers. Therefore there is no way to render the HTML of this component in a Node.js environment without the help of libraries, such as JSDom, that emulate client functionality. However, thanks to the Component.renderToString method, out of the box server side rendering of Metal components is possible in Node.js environments: const Component = require('metal-component').Component; const MyComponent = require('./MyComponent').MyComponent; const htmlString = Component.renderToString(MyComponent, { message: 'Hello, World!' }); // htmlString === 'Hello, World!' Now all of your custom Metal components can be rendered directly to HTML on the server. ","srcFilePath":"src/pages/docs/guides/isomorphic.md","id":"isomorphic","location":"/docs/guides/isomorphic.html","url":"/docs/guides/isomorphic.html"},"jsx-components":{"title":"JSX Components","description":"","layout":"guide","weight":190,"content":" For a practical tutorial on how to build components using JSX templates, make sure to go through the Todo App tutorial. This guide will explain some details about the integration between {sp}Metal.js components and JSX templates. Note that Metal.js is template agnostic, so it's not necessary to use JSX at all. That said, we already provide a very good integration between metal components and JSX, so if you like using it you should give it a try. JSXComponent The only thing you need to do to use JSX in your Metal.js component is to extend from JSXComponent, like this: import JSXComponent from 'metal-jsx'; class MyComponent extends JSXComponent { } export default MyComponent; render Function Now that we've extended from JSXComponent we can use jsx in the render{sp} method to specify what our component should render. import JSXComponent from 'metal-jsx'; class MyComponent extends JSXComponent { render() { return ( Hello {this.state.name} Hello {this.props.location} ; ); } } MyComponent.PROPS = { location: { validator: core.isString, value: 'Mars' } }; MyComponent.STATE = { name: { validator: core.isString, value: 'World' } }; export default MyComponent; Note that your component can have two different types of data: {sp}state and props. The main difference is that props is accessed via this.props and will be the original data received from parent components or the constructor. State is accessed from this.state though, like this.state.name in the previous example, and can be configured to use validators, setters, initial values and other features. Check out the guide about state to learn more about this. Children Props Whenever content is passed inside a component's jsx tag, it will be received through the children props property. That way the component can decide if this content will be rendered at all, and where exactly it should go. For example, imagine a simple list component that receives its items as its content, like this: Item 1 Item 2 Item 3 This could be implemented by using the children props: class List extends JSXComponent { render() { return {this.props.children} } } If you inspect this.props.children you'll notice that it's an array of objects. That gives you a lot of power when handling your component's contents. For example, you can choose to render only part of your children, like this: // Renders only the second item. return {this.props.children[1]} Or even change the data that they should receive before being rendered: // Forces all items to use the 'my-list-item-class' CSS class. this.props.children.forEach(child = { child.class = 'my-list-item-class'; }; return {this.props.children} Functional Components Sometimes you'll create very simple components, that have no other behavior besides rendering their own contents. In this case you can drop using classes, and instead create simple functions that just render the contents instead. For example, let's create a simple Button component as a function: /** Functional components receive the configuration object as the first param. */ var Button = ({ cssClass, label }) = { return {label}; }; You can then use it from parent components in the same way that you'd use a component class, for example: Rendering JSX Components JSX components can either be rendered in the {sp}usual way, or via the JSXComponent.render{sp} function, like this: class Button extends JSXComponent { render() { // Your render logic } } JSXComponent.render(Button, {label: 'OK'}, parent); You can also pass a functional component to it: var Button = props = { // Your render logic }; JSXComponent.render(Button, {label: 'OK'}, parent); Or even render directly via JSX: JSXComponent.render(, parent); JSX Compilation For the integration between Metal.js and JSX to work, the JSX code needs to be compiled via a babel plugin called {sp}babel-plugin-incremental-dom. Using it directly means you'd need to configure it manually though, so we also provide a babel preset that you can use instead. Helpers There are a few additional helpers we also provide for JSX. this.otherProps() Used for passing non-named props directly through to the child component. import JSXComponent, {Config} from 'metal-jsx'; class MyComponent extends JSXComponent { render() { return ( ) } } MyComponent.PROPS = { foo: Config.string() } // baz will be passed directly to ChildComponent `` Component used for rendering a string as HTML. import JSXComponent, {DangerouslySetHTML} from 'metal-jsx'; class MyComponent extends JSXComponent { render() { return ( ) } } // renders Hello World `` Component used to return an array of elements. import JSXComponent, {Fragment} from 'metal-jsx'; class MyComponent extends JSXComponent { render() { return ( {['foo', 'bar', 'baz'].map( name = ( Input {name} ) )} ) } } // renders Input foo Input bar Input baz ","srcFilePath":"src/pages/docs/guides/jsx-components.md","id":"jsx-components","location":"/docs/guides/jsx-components.html","url":"/docs/guides/jsx-components.html"},"performance":{"title":"Performance","description":"","layout":"guide","weight":230,"content":" Performance Metal.js was built from the first with performance in mind. We've run performance tests to compare it with other libraries and got really good results that show the benefits of using it. In one of the tests we made, we built a simple list widget on three different libraries: Metal.js, YUI and React. We then measured the time it took to render those widgets with 1000 items each on three different situations: First Render - Creating and rendering the list for the first time, on a blank element. Decorate - Creating and decorating a list that was previously rendered on the DOM. Update - Changing the contents of the first item of the list, causing a rerender. The chart below shows the results we obtained on Chrome (the higher the bar, the faster it runs): ","srcFilePath":"src/pages/docs/guides/performance.md","id":"performance","location":"/docs/guides/performance.html","url":"/docs/guides/performance.html"},"portals":{"title":"Portals","description":"How to render child components to a different part of the page.","layout":"guide","weight":195,"content":" Portals Normally when rendering child components, the generated markup is nested exactly where the child component is. Take the following JSX snippet for example. class Child extends JSXComponent { render() { return ; } } class Parent extends JSXComponent { render() { return } } // Resulting markup But what if you need to render the component elsewhere? Occasionally it's necessary to render a child component outside the DOM hierarchy of the parent component. This is where Portals come in. class Child extends JSXComponent { render() { return ; } } class Parent extends JSXComponent { render() { return } } Now the markup of Child will be rendered to the target element on the page, but will still receive updates from any data being passed from Parent. It will also be disposed and detached from the page along with it's parent. This is especially useful when creating components such as modals, dropdowns, tooltips, or any component that needs to always overlay other pieces of content. Configuration The portalElement property can receive three different types of values: DOM elements, string selectors, or a boolean. DOM elements and string selectors will work as expected: // Is the same as Passing true will select the body element by default: // Is the same as Passing false will disable the Portal and render the component inline as normal. Soy example Portals are supported for Soy components as well. The portalElement receives the same values as a JSX component. Here is a snippet where a selector is passed. &#123;namespace Parent&#125; /** This renders the component's whole content. */ &#123;template .render&#125; {call Child.render} {param portalElement: \"#target\" /} {/call} &#123;/template&#125; Limitations There are a couple of known limitations when using Portals. Parent element The main limitation of portalElement is that it cannot be set to the same element that houses the root level parent component. class Child extends JSXComponent { render() { return ; } } class Parent extends JSXComponent { render() { // Wrong: rendering Child to same element as parent return } } // Rendering Parent to the #target element new Parent(null, '#target'); With this configuration, Incremental DOM will throw an error when the Parent component attempts to remove the Child component from the page. Using elements rendered by parent While it is recommended to not use elements created by Metal components as a portalElement, it is possible with the right configuration. The limitation is that portalElement needs to be passed an element that exists before the component is rendered. This may seem obvious but take the following snippet as an example. class Child extends JSXComponent { render() { return ; } } class Parent extends JSXComponent { render() { // Rendering Child to element created by parent return } } In this example Child will not render to the specified portalElement, as the target element will not exist at the time of rendering due to how Incremental DOM creates elements. The solution is to wrap the Child component in a conditional that will only render it after some kind of user interaction, such as a click. class Child extends JSXComponent { render() { return ; } } class Parent extends JSXComponent { render() { return { this.state.clicked = !this.state.clicked; }} Toggle {this.state.clicked && } } } Parent.STATE = { clicked: { value: false } }; While this should work for the Child component's first render, you will run into problems once the Parent component starts updating. Portals need to be passed an element that is not removed or modified in any way. This can be accomplished by using a third Component that always returns false in it's shouldUpdate lifecycle method, and using it as the portalElement for the Child component. class Child extends JSXComponent { render() { return ; } } class Host extends JSXComponent { render() { return ; } shouldUpdate() { return false; } } class Parent extends JSXComponent { render() { return { this.state.clicked = !this.state.clicked; }} Toggle {this.state.clicked && } } } Parent.STATE = { clicked: { value: false } }; Now we have a working example where Child is successfully rendered to a portalElement that was also created by a Metal component. ","srcFilePath":"src/pages/docs/guides/portals.md","id":"portals","location":"/docs/guides/portals.html","url":"/docs/guides/portals.html"},"progressive-enhancement":{"title":"Progressive Enhancement","description":"","layout":"guide","weight":200,"content":" Progressive Enhancement Progressive enhancement{sp} is a feature that is very important for a lot of people. Knowing about this, {sp}Metal.js is prepared to deal with content that already comes rendered from the server. Since Metal.js components use {sp}Incremental DOM by default, rendering on an element with existing content will reuse it instead of repainting everything. It's important to note that building components with Soy also helps with progressive enhancement in another way: by providing a faithful template that can be run by the server without having to duplicate the rendering code or run JavaScript at all. ","srcFilePath":"src/pages/docs/guides/progressive-enhancement.md","id":"progressive-enhancement","location":"/docs/guides/progressive-enhancement.html","url":"/docs/guides/progressive-enhancement.html"},"rendering-components":{"title":"Rendering Components","description":"","layout":"guide","weight":140,"content":" The quick start tutorial explains how to create and render a new component. In its examples components are always being appended directly to the document's body though, but what's usually necessary is to render in a specific position. Replacing an Existing Element If you wish your component to replace an existing element on the DOM, you just need to pass it (or a selector for it) as the element property of the constructor configuration, like this: // Passsing the element itself new Modal({element: elementToReplace}); // Passing a selector to the element new Modal({element: 'elementToReplace'}); Specifying the Parent You can also specify the parent element that should receive the component's contents via the second constructor param, like this: // Passing the element itself new Modal(data, parentElement); // Passing a selector to the element new Modal(data, 'parentElement'); ","srcFilePath":"src/pages/docs/guides/rendering-components.md","id":"rendering-components","location":"/docs/guides/rendering-components.html","url":"/docs/guides/rendering-components.html"},"soy-components":{"title":"Soy Components","description":"","layout":"guide","weight":180,"content":" For a full tutorial on how to build components using Soy templates, make sure to go through the Todo App tutorial. This guide will explain some details about the integration between Metal.js{sp} components and Soy templates. Note that Metal.js is template agnostic, so it's not necessary to use Soy at all. That said, we already provide a very good integration between Metal.js components and Soy, so if you like this template language you should give it a try. Soy.register The only thing you need to do to use Soy templates in your Metal.js{sp} component is to call Soy.register, passing it your component class and the Soy templates you're going to use, like this: import templates from './MyComponent.soy'; import Component from 'metal-component'; import Soy from 'metal-soy'; class MyComponent extends Component { } Soy.register(MyComponent, templates); export default MyComponent; By default, Metal.js will use the Soy template called render as the entry point for rendering. But you can tell us to use a different one if you prefer by passing the name as the last param to the Soy.register call, like this: Soy.register(MyComponent, templates, 'templateName'); Template File Make sure that your Soy file has the entry point template (render by default), otherwise nothing will be rendered. This main template will receive as data a combination of: State data Configuration data (accessed through this.config) Component functions Note that by default all params declared on the component's main Soy template are automatically configured as state properties as well, but without any special configurations (like initial value or validators). If they're {sp}manually defined through the STATE property they will retain the setup specified there though. Any params passed to the component but not directly declared on its main Soy template will be treated as basic configuration data, meaning that changes to them will not automatically rerender the component. They can still be passed down to other templates using data=\"all\", as well be accessed via the config property in the JavaScript file. // Contains all the data received by the component. this.config Soy Compilation For the integration between Metal.js and soy to work, the Soy files need to be compiled via one of our available build tools. That's because they don't just compile the code, but also add some information that help with the integration (like export declarations). The available build tools that correctly compile Soy for Metal.js are: gulp-metal (already included when creating project via generator-metal). metal-cli metal-tools-soy ","srcFilePath":"src/pages/docs/guides/soy-components.md","id":"soy-components","location":"/docs/guides/soy-components.html","url":"/docs/guides/soy-components.html"},"state":{"title":"State","description":"","layout":"guide","weight":110,"content":" The State class provides a way of defining state properties for the classes that extend it, as well as watching these properties for value changes. The Component class already extends from State by default, besides automatically rerendering when there is a change. If your class doesn't need to render anything it's best to extend from {sp}State directly though. That way you'll have access to its features without also inheriting logic you won't need. Configuring State The following example is a class that extends directly from State and defines a state property named number on itself: import core from 'metal'; import State from 'metal-state'; class Calculator extends State { /** Coverts string numbers to the number type. */ setNumber(val) { if (core.isString(val)) { val = parseInt(val, 10); } return val; } } Calculator.STATE = { number: { // Called whenever a new value is set. Useful when normalizing your // state data. setter: 'setNumber', // Accepts either number or string types. If the validator check fails, // the new value is discarded, and the current value kept. validator: val = core.isNumber(val) || core.isString(val), // Initial value value: 0, // You can, instead of the value option above, use a function to // return the initial value for the state. valueFn: val = 0, // It's also possible to define that a property can only receive a // value once, and later behave as read-only. writeOnce: false } } If you're familiar with YUI, you may recognize this feature and notice that it's very similar to how attributes are defined there. You basically just need to list all attributes you'll be using on the {sp}STATE static variable (on YUI it would be on ATTRS), and provide their configuration options, like initial value and validator. For a list of all valid options, take a look at State's {sp}docs. Internal States You can define a state as internal, for use in your component only. Just add the attribute internal to the configuration object. By doing this, the state will behave exactly as expected, including re-rendering the component. The only difference being, internal states can not be accessed by parent components. This is not necessary for JSX components, since Metal.js JSX components have their own State Manager implementation. For that reason, two static properties are used, STATE and PROPS, that behave much closer to React's {sp}state and props. To see exactly how it works read JSX components section. Calculator.STATE = { number: { ... internal: true } } Accessing and Updating State The constructor can receive a configuration object with initial values to use for its state properties. You can access or change an object's state in the same way you'd access or change any object property. Or you can also call the {sp}setState function, which updates the properties specified by the given object. var obj = new Calculator(); console.log(obj.number); // Prints 0 obj.number = '1'; console.log(obj.number); // Prints 1 obj.setState({number: 2}); console.log(obj.number); // Prints 2 You can also track state value changes by listening to the appropriate event. obj.on('numberChanged', function(event) { // event.prevVal has the previous value. // event.newVal has the new value. }); To see all features of the State class take a look at its {sp}unit tests. Configuration Data Any data passed to the constructor that has not been configured as a state property can still be accessed via config. Changes to these properties won't be tracked, so it's usually intended for your component's options, which are only set from the outside. var obj = new Calculator({ number: 10, foo: 'foo' }); console.log(obj.number); // Prints 2 console.log(obj.foo); // Prints undefined console.log(obj.config.foo); // Prints 'foo' ","srcFilePath":"src/pages/docs/guides/state.md","id":"state","location":"/docs/guides/state.html","url":"/docs/guides/state.html"},"web-components":{"title":"Web Components","description":"Using metal components as web components (custom elements).","layout":"guide","weight":230,"content":" Web Components Metal components are generally invoked in one of three ways: JavaScript new metal.MyComponent({ title: 'Hello, World!' }, 'element'); Soy {call MyComponent.render} {param title: \"Hello, World!\" /} {/call} JSX However, with the help of the metal-web-component package, Metal components can be invoked as Custom Elements in plain HTML. Install First you must install the metal-web-component package: npm i --save metal-web-component Currently, web components don't work on every browser, so a polyfill must be used. Include the webcomponents-lite polyfill if you intend to use web components on Firefox, Edge, or IE11. Define web components This package exposes a single helper function that can be used to wrap any Metal component in a web component. It receives two arguments: the tag name you want the web component to receive, and the constructor of the Metal component: import JSXComponent from 'metal-jsx'; import defineWebComponent from 'metal-web-component'; class MyComponent extends JSXComponent { render() { return {this.props.message} } } MyComponent.PROPS = { message: { value: '' } }; defineWebComponent('my-component', MyComponent); Now that the web component is defined, it can be invoked in plain html: This results in the following HTML on the page: This is a web component If you would like the component's markup to be rendered using the Shadow DOM, simply set the useshadowdom attribute to true when calling the web component: This means that any styling on the page will not cascade to your component's markup. See MDN's documentation for more info. ","srcFilePath":"src/pages/docs/guides/web-components.md","id":"web-components","location":"/docs/guides/web-components.html","url":"/docs/guides/web-components.html"},"yeoman-generator":{"title":"Yeoman Generator","description":"","layout":"guide","weight":210,"content":" Yeoman Generator You can organize your Metal.js project in any way you want, but to start out we recommend using the {sp}Yeoman generator we've created, which prepares both the project structure as well as a basic development workflow for you. To use it: Install npm v3.0.0 or newer (if you don't have it yet) Install Yeoman and generator-metal: [sudo] npm i -g yo generator-metal Open the folder that you want to use on your terminal and type: yo metal Answer the generator prompts: Wait for the generator to finish fetching dependencies After those steps you'll get a directory tree similar to this: └── metal-modal ├── demos │ └── index.html ├── node_modules ├── package.json ├── src │ ├── Modal.js │ ├── Modal.soy // Only if Soy was chosen │ └── modal.scss └── test └── Modal.js generator-metal will already include some npm scripts to help you build and test your code, as well as many gulp tasks via {sp}gulp-metal. ","srcFilePath":"src/pages/docs/guides/yeoman-generator.md","id":"yeoman-generator","location":"/docs/guides/yeoman-generator.html","url":"/docs/guides/yeoman-generator.html"}},"title":"Guides","url":"/docs/guides/alias.html","icon":"streams","weight":2,"content":" ","srcFilePath":"src/pages/docs/guides/index.soy","id":"guides","location":"/docs/guides/","customURL":true,"childIds":["alias","state","component-lifecycle","rendering-components","inline-events","importing","soy-components","jsx-components","portals","progressive-enhancement","yeoman-generator","building","performance","web-components","isomorphic"]},"tutorials":{"description":"Tutorials for learning Metal.js.","title":"Tutorials","icon":"menu","weight":1,"content":" Select the tutorial you would like to begin. ","srcFilePath":"src/pages/docs/tutorials/index.soy","id":"tutorials","location":"/docs/tutorials/","url":"/docs/tutorials/","children":{"tutorial-todo-soy":{"children":{"adding-todos":{"title":"Adding Todos","description":"Foo bar.","parentId":"tutorial-todo-soy","layout":"tutorial","time":90,"weight":8,"content":" {$page.title} You almost have a fully functioning Todo App! The only missing feature is the ability to add new todos to the list. This is where the TodoForm component comes into play. First, go ahead and add a couple of event listeners: one for the form submission (onsubmit) and one for when the input value changes (onkeyup): // TodoForm.js class TodoForm extends Component { handleSubmit(event) { // Prevent default browser functionality event.preventDefault(); } handleChange(event) { } } &123;namespace TodoForm&#125; /** This renders the component's whole content. */ &#123;template .render&#125; Todo Add &#123;/template&#125; Now you can use the value property from STATE to keep track of the changes made to the input value. This makes the input a controlled input, where the value of the input is controlled by the state of the component. In other words, when the value of the state changes, it automatically changes the value in the input as well, keeping the two in sync. // TodoForm.js class TodoForm extends Component { ... handleChange(event) { this.value = event.target.value; } } &#123;namespace TodoForm&#125; /** This renders the component's whole content. */ &#123;template .render&#125; {@param? value: string} Todo Add &#123;/template&#125; The value of this.value will now match the value in the input. You can also emit a custom event when the form is submitted, similarly to what TodoItem does to notify the parent component that something happened: // TodoForm.js class TodoForm extends Component { ... handleSubmit(event) { event.preventDefault(); if (this.value) { this.emit('todoAdd', { title: this.value }); // Clears the input value this.value = ''; } } } Then in the TodoApp component, you can listen to this event and add a new todo: // TodoApp.js class TodoApp extends Component { addTodo(title) { // Creates a new array with all of the elements // from the previous array, with the newly added item this.todos = [...this.todos, { done: false, title }]; } handleTodoAdd(event) { this.addTodo(event.title); } ... } &#123;namespace TodoApp&#125; /** This renders the component's whole content. */ &#123;template .render&#125; {@param? handleTodoAdd: ?} {@param? handleTodoClick: ?} {@param? todos: ?} ... {call TodoForm.render} {param events: ['todoAdd' : $handleTodoAdd] /} {/call} &#123;/template&#125; Now when you add some text to the input and submit the form, a new todo is automatically added to the list. That's it! You've successfully created a simple Todo App with Metal.js. Now that you are comfortable with the basics, check out the guides for more advanced documentation. ","srcFilePath":"src/pages/docs/tutorials/tutorial-todo-soy/adding-todos.md","id":"adding-todos","location":"/docs/tutorials/tutorial-todo-soy/adding-todos.html","url":"/docs/tutorials/tutorial-todo-soy/adding-todos.html"},"before-we-start":{"title":"Before We Start","description":"Explanation of what Metal.js is intended for, and what you'll make in this tutorial.","buttonTitle":"Let's get started","parentId":"tutorial-todo-soy","layout":"tutorial","time":90,"weight":1,"content":" {$page.title} Before we actually make anything, let's discuss what Metal.js is and what it's intended for. Note: if you're interested in using Metal.js with JSX templates, check out the JSX tutorial instead. Data flow If you're familiar with React, you'll feel right at home. Metal.js is a foundation for creating UI components that automatically respond to data when it's updated. In other words, it's a framework for creating one-way data binding components. This is different from frameworks like Angular, which provide a two-way data binding solution. Templating Metal.js is template agnostic and comes with out-of-the-box support for two templating languages: Soy (Google Closure) and JSX (React). When the data being passed to your component changes, your component's template rerenders just the parts of your component that need to be updated. Therefore, you don't need to worry about manual DOM manipulation. Behind the scenes Metal.js is using Google's Incremental DOM for updating DOM elements. What are we making? In this tutorial, we'll be making a simple Todo App that let's you mark items as completed and add new items to the list. If you would like to see the finished product check out the metal-tutorial-todo repository. ","srcFilePath":"src/pages/docs/tutorials/tutorial-todo-soy/before-we-start.md","id":"before-we-start","location":"/docs/tutorials/tutorial-todo-soy/before-we-start.html","url":"/docs/tutorials/tutorial-todo-soy/before-we-start.html"},"components":{"title":"Components","description":"asdf","buttonTitle":"Next","parentId":"tutorial-todo-soy","layout":"tutorial","time":90,"weight":3,"content":" {$page.title} In the metal-tutorial-todo boilerplate there are already three components defined to help get you started. Each component is defined as an ES6 class that extends from Metal's Component class: class TodoApp extends Component { } Each component registers a Soy template that renders the component's HTML. This is done with the Soy.register method: import templates from './TodoApp.soy.js'; import Component from 'metal-component'; import Soy from 'metal-soy'; class TodoApp extends Component { } Soy.register(TodoApp, templates); The TodoApp component will be the root level component. It will handle storing the todo data, and the rendering of the other two components. The TodoItem component will render each item in the list of todos. The TodoForm component will render a form for adding new todo items to the list. It will consist of a text input and add button. Why more than one? It might seem more trouble than it's worth splitting up the Todo App into multiple components, but it's absolutely necessary when creating larger applications. This tutorial aims to teach you how to handle nested components for more complex use cases. ","srcFilePath":"src/pages/docs/tutorials/tutorial-todo-soy/components.md","id":"components","location":"/docs/tutorials/tutorial-todo-soy/components.html","url":"/docs/tutorials/tutorial-todo-soy/components.html"},"configurating-state":{"title":"Configuring State","description":"How to configure state and props for Metal.js components.","buttonTitle":"I configured the state","parentId":"tutorial-todo-soy","layout":"tutorial","time":90,"weight":4,"content":" {$page.title} As previously mentioned, Metal components automatically respond to the data passed to them and rerender. For a component to take advantage of this behavior, however, it needs to be told what data to respond to. This is where state comes in. JSX components have two state managers, one for internal state (STATE), and one for external properties that are passed down to it (PROPS). Soy components on the other hand only have one state manager that is used for both internal and external properties (STATE). Storing The Todos Let's configure the TodoApp component to store an array of todos with a default value: // TodoApp.js class TodoApp extends Component { ... } TodoApp.STATE = { todos: { // Default value value: [ { done: false, title: 'Todo 1' }, { done: false, title: 'Todo 2' } ] } }; Now that there is a default value set, you can access the value in the Soy template after defining it as a soy param: &#123;namespace TodoApp&#125; /** This renders the component's whole content. */ &#123;template .render&#125; {@param? todos: ?} Todo: {$todos[0].title} &#123;/template&#125; Which results in the following markup: Todo: Todo 1 Obviously, this markup isn't very useful. We'll get to rendering the entire list in a minute. Item The TodoItem component will need two properties defined in STATE: one for keeping track of it's index inside the list and one for containing the todo data itself: // TodoItem.js class TodoItem extends Component { ... } TodoItem.STATE = { index: { value: null }, todo: { value: null } }; These STATE properties will act as read-only for the TodoItem component, as the values will always be defined by the parent component and passed down. Form The TodoForm only needs one property that will eventually be used to keep track of the value of it's input: // TodoForm.js class TodoForm extends Component { ... } TodoForm.STATE = { value: { value: '' } }; ","srcFilePath":"src/pages/docs/tutorials/tutorial-todo-soy/configurating-state.md","id":"configurating-state","location":"/docs/tutorials/tutorial-todo-soy/configurating-state.html","url":"/docs/tutorials/tutorial-todo-soy/configurating-state.html"},"dependencies":{"title":"Dependencies","description":"Installing dependencies of Metal.js.","buttonTitle":"I installed the dependencies","parentId":"tutorial-todo-soy","layout":"tutorial","time":90,"weight":2,"content":" {$page.title} To follow along with this tutorial, you'll need Git and a recent version of Node.js/npm. You'll also need the Java Runtime Environment (JRE) installed to compile the .soy files. Todo Boilerplate Start by cloning the boilerplate repository: git clone https://github.com/metal/metal-tutorial-todo.git Then navigate to the root of the project in your terminal and install the local npm dependencies: cd metal-tutorial-todo && npm install The boilerplate that you'll build on is located in the src/soy directory. You can also view the finished product in the src/soy/final directory. Building To test drive the boilerplate located in the src/soy directory, run the build script shown below: npm run build:soy This runs babel + webpack to transpile and bundle the JavaScript into something consumable by web browsers. This tutorial uses ES6 syntax; if you're unfamiliar with it, check out this guide first. To build the finished product, run the following script: npm run build:soy:final Demo Now that you've built the project, go ahead and open the demo page located at demos/index.html. If you check the file you'll see that the component is already being invoked: new metal.TodoApp(); When you invoke a component this way, it is rendered to the body element. ","srcFilePath":"src/pages/docs/tutorials/tutorial-todo-soy/dependencies.md","id":"dependencies","location":"/docs/tutorials/tutorial-todo-soy/dependencies.html","url":"/docs/tutorials/tutorial-todo-soy/dependencies.html"},"event-listeners":{"title":"Event Listeners","description":"Foo bar.","buttonTitle":"I added the event listeners","parentId":"tutorial-todo-soy","layout":"tutorial","time":90,"weight":6,"content":" {$page.title} Now you should have a static list of todo items. What now? Remember the end goal is to be able to click the todos to mark them as completed, so let's start with adding a click event listener to the list items: // TodoItem.js class TodoItem extends Component { ... handleClick(event) { alert(this.todo.title); } } &123;namespace TodoItem&#125; /** This renders the component's whole content. */ &#123;template .render&#125; {@param todo: ?} {let $elementClasses kind=\"text\"} todo-item {if $todo.done} {sp}todo-item-done {/if} {/let} {$todo.title} &#123;/template&#125; Notice that only the method name is passed to the data-onclick property. Metal automatically checks to see if the Component has that method. Now you should see an alert with the title of the clicked todo. Next you must notify TodoApp that a todo was marked as completed so that it can update the data. This can be done by emitting a custom event with the info needed to make the change. In this case we'll use the index value from STATE: // TodoItem.js class TodoItem extends Component { ... handleClick(event) { this.emit('todoClick', { index: this.index }); } } Now that the TodoItem is emitting an event, you must add a listener from the parent component TodoApp. You can accomplish this by creating a function reference. This is simply a Soy param that refers to the method you want to use as the callback. // TodoApp.js class TodoApp extends Component { ... handleTodoClick(event) { alert(event.index); } } &#123;namespace TodoApp&#125; /** This renders the component's whole content. */ &#123;template .render&#125; // Function reference {@param? handleTodoClick: ?} {@param? todos: ?} {foreach $todo in $todos} {call TodoItem.render} // Adds the listener for the todoClick event {param events: ['todoClick' : $handleTodoClick] /} {param index: index($todo) /} {param todo: $todo /} {/call} {/foreach} &#123;/template&#125; At this point you should have an event handler that fires every time a todo item is clicked. Next you will use this data to update the state in TodoApp. Alternative to custom events Alternatively, you can pass functions from parents to children to achieve similar functionality. To do this, a child must declare a STATE property to house the function from the parent: class Parent extends Component { handleChange(event) { // Logic } } class Child extends Component { someMethod() { this.onChange({ // Payload }); } } Child.STATE = { onChange: { } } &123;namespace Parent} {@param? handleChange: ?} {call Child.render} {param onChange: $handleChange /} {/call} &#123;/samespace} ","srcFilePath":"src/pages/docs/tutorials/tutorial-todo-soy/event-listeners.md","id":"event-listeners","location":"/docs/tutorials/tutorial-todo-soy/event-listeners.html","url":"/docs/tutorials/tutorial-todo-soy/event-listeners.html"},"rendering-data":{"title":"Rendering Data","description":"Foo bar.","buttonTitle":"I rendered the todo items","parentId":"tutorial-todo-soy","layout":"tutorial","time":90,"weight":5,"content":" {$page.title} First, let's prepare the TodoItem for consuming the data passed from TodoApp: &123;namespace TodoItem&#125; /** This renders the component's whole content. */ &#123;template .render&#125; {@param todo: ?} {let $elementClasses kind=\"text\"} todo-item // Conditionally adding the 'todo-item-done' class if // the todo is done {if $todo.done} {sp}todo-item-done {/if} {/let} {$todo.title} &#123;/template&#125; Now that you have some data that needs rendering and the TodoItem is ready to consume it, you need to iterate over the todos and pass them to the child components: &#123;namespace TodoApp&#125; /** This renders the component's whole content. */ &#123;template .render&#125; {@param? todos: ?} {foreach $todo in $todos} {call TodoItem.render} {param index: index($todo) /} {param todo: $todo /} {/call} {/foreach} &#123;/template&#125; This results in the following markup: Todo 1 Todo 2 ","srcFilePath":"src/pages/docs/tutorials/tutorial-todo-soy/rendering-data.md","id":"rendering-data","location":"/docs/tutorials/tutorial-todo-soy/rendering-data.html","url":"/docs/tutorials/tutorial-todo-soy/rendering-data.html"},"updating-state":{"title":"Updating State","description":"Foo bar.","buttonTitle":"I updated the state","parentId":"tutorial-todo-soy","layout":"tutorial","time":90,"weight":7,"content":" {$page.title} Now you're ready to update the state in TodoApp. In the last step, you added an event listener: // TodoApp.js class TodoApp extends Component { ... handleTodoClick(event) { alert(event.index); } } Now all you need to do is update the state so that the template rerenders: // TodoApp.js class TodoApp extends Component { ... handleTodoClick(event) { this.toggleTodo(event.index); } toggleTodo(clickedIndex) { this.todos = this.todos.map((todo, index) = { if (clickedIndex === index) { todo.done = !todo.done; } return todo; }); } } This toggles the done property of the todo that was clicked. Simply setting the this.todos property to a new array of todos triggers a rerender, passing the data to the child components. Your markup should look like this once you've clicked a todo item: Todo 1 Todo 2 ","srcFilePath":"src/pages/docs/tutorials/tutorial-todo-soy/updating-state.md","id":"updating-state","location":"/docs/tutorials/tutorial-todo-soy/updating-state.html","url":"/docs/tutorials/tutorial-todo-soy/updating-state.html"}},"title":"Todo App: Soy","description":"Learn to create a simple Todo App with Metal.js and Soy.","icon":"menu","tutorialTitle":"Learn to create a simple Todo App with Metal.js and Soy","url":"/docs/tutorials/tutorial-todo-soy/before-we-start.html","content":" ","srcFilePath":"src/pages/docs/tutorials/tutorial-todo-soy/index.soy","id":"tutorial-todo-soy","location":"/docs/tutorials/tutorial-todo-soy/","customURL":true,"childIds":["before-we-start","dependencies","components","configurating-state","rendering-data","event-listeners","updating-state","adding-todos"]},"tutorial-todo-jsx":{"children":{"adding-todos":{"title":"Adding Todos","description":"Foo bar.","parentId":"tutorial-todo-jsx","layout":"tutorial","time":90,"weight":8,"content":" {$page.title} You almost have a fully functioning Todo App! The only missing feature is the ability to add new todos to the list. This is where the TodoForm component comes into play. First, go ahead and add a couple of event listeners: one for the form submission (onsubmit) and one for when the input value changes (onkeyup): // TodoForm.js class TodoForm extends JSXComponent { render() { return ( Todo Add ); } handleSubmit(event) { // Prevent default browser functionality event.preventDefault(); } handleChange(event) { } } Now you can use the value property from STATE to keep track of the changes made to the input value. This makes the input a controlled input, where the value of the input is controlled by the state of the component. In other words, when the value of the state changes, it automatically changes the value in the input as well, keeping the two in sync. // TodoForm.js class TodoForm extends JSXComponent { render() { return ( Todo Add ); } ... handleChange(event) { this.state.value = event.target.value; } } The value of this.state.value will now match the value in the input. You can also emit a custom event when the form is submitted, similarly to what TodoItem does to notify the parent component that something happened: // TodoForm.js class TodoForm extends JSXComponent { ... handleSubmit(event) { event.preventDefault(); if (this.state.value) { this.emit('todoAdd', { title: this.state.value }); // Clears the input value this.state.value = ''; } } } Then in the TodoApp component, you can listen to this event and add a new todo: // TodoApp.js class TodoApp extends JSXComponent { render() { return ( ... ); } addTodo(title) { // Creates a new array with all of the elements // from the previous array, with the newly added item this.state.todos = [...this.state.todos, { done: false, title }]; } handleTodoAdd(event) { this.addTodo(event.title); } ... } Now when you add some text to the input and submit the form, a new todo is automatically added to the list. That's it! You've successfully created a simple Todo App with Metal.js. Now that you are comfortable with the basics, check out the guides for more advanced documentation. ","srcFilePath":"src/pages/docs/tutorials/tutorial-todo-jsx/adding-todos.md","id":"adding-todos","location":"/docs/tutorials/tutorial-todo-jsx/adding-todos.html","url":"/docs/tutorials/tutorial-todo-jsx/adding-todos.html"},"before-we-start":{"title":"Before We Start","description":"Explanation of what Metal.js is intended for, and what you'll make in this tutorial.","buttonTitle":"Let's get started","parentId":"tutorial-todo-jsx","layout":"tutorial","time":90,"weight":1,"content":" {$page.title} Before we actually make anything, let's discuss what Metal.js is and what it's intended for. Note: if you're interested in using Metal.js with Soy templates, check out the Soy tutorial instead. Data flow If you're familiar with React, you'll feel right at home. Metal.js is a foundation for creating UI components that automatically respond to data when it's updated. In other words, it's a framework for creating one-way data binding components. This is different from frameworks like Angular, which provide a two-way data binding solution. Templating Metal.js is template agnostic and comes with out-of-the-box support for two templating languages: Soy (Google Closure) and JSX (React). When the data being passed to your component changes, your component's template rerenders just the parts of your component that need to be updated. Therefore, you don't need to worry about manual DOM manipulation. Behind the scenes Metal.js is using Google's Incremental DOM for updating DOM elements. What are we making? In this tutorial, we'll be making a simple Todo App that let's you mark items as completed and add new items to the list. If you would like to see the finished product check out the metal-tutorial-todo repository. ","srcFilePath":"src/pages/docs/tutorials/tutorial-todo-jsx/before-we-start.md","id":"before-we-start","location":"/docs/tutorials/tutorial-todo-jsx/before-we-start.html","url":"/docs/tutorials/tutorial-todo-jsx/before-we-start.html"},"components":{"title":"Components","description":"asdf","buttonTitle":"Next","parentId":"tutorial-todo-jsx","layout":"tutorial","time":90,"weight":3,"content":" {$page.title} In the metal-tutorial-todo boilerplate there are already three components defined to help get you started. Each component is defined as an ES6 class that extends from Metal's JSXComponent class: class TodoApp extends JSXComponent { } Each component has a render function where the JSX template is defined. This creates the HTML you see in the demo page: class TodoApp extends JSXComponent { return ( Hello, World ); } The TodoApp component will be the root level component. It will handle storing the todo data, and the rendering of the other two components. The TodoItem component will render each item in the list of todos. The TodoForm component will render a form for adding new todo items to the list. It will consist of a text input and add button. Why more than one? It might seem more trouble than it's worth splitting up the Todo App into multiple components, but it's absolutely necessary when creating larger applications. This tutorial aims to teach you how to handle nested components for more complex use cases. ","srcFilePath":"src/pages/docs/tutorials/tutorial-todo-jsx/components.md","id":"components","location":"/docs/tutorials/tutorial-todo-jsx/components.html","url":"/docs/tutorials/tutorial-todo-jsx/components.html"},"configurating-state":{"title":"Configuring State","description":"How to configure state and props for Metal.js components.","buttonTitle":"I configured the state","parentId":"tutorial-todo-jsx","layout":"tutorial","time":90,"weight":4,"content":" {$page.title} As previously mentioned, Metal components automatically respond to the data passed to them and rerender. For a component to take advantage of this behavior, however, it needs to be told what data to respond to. This is where state comes in. JSX components have two state managers, one for internal state (STATE), and one for external properties that are passed down to it (PROPS). Soy components on the other hand only have one state manager that is used for both internal and external properties (STATE). Storing The Todos Let's configure the TodoApp component to store an array of todos with a default value: // TodoApp.js class TodoApp extends JSXComponent { ... } TodoApp.STATE = { todos: { // Default value value: [ { done: false, title: 'Todo 1' }, { done: false, title: 'Todo 2' } ] } }; Now that there is a default value set, you can access the value in the render function using this.state: // TodoApp.js class TodoApp extends JSXComponent { render() { return ( Todo: {this.state.todos[0].title} ); } } Which results in the following markup: Todo: Todo 1 Obviously, this markup isn't very useful. We'll get to rendering the entire list in a minute. Item The TodoItem component will need two PROPS: one for keeping track of it's index inside the list and one for containing the todo data itself: // TodoItem.js class TodoItem extends JSXComponent { ... } TodoItem.PROPS = { index: { value: null }, todo: { value: null } }; Remember that PROPS are used for external data, or data that is passed to the component from a parent. Therefore these values will be read-only for the TodoItem component. Form The TodoForm only needs one property that will only ever be set internally, therefore it's set on STATE: // TodoForm.js class TodoForm extends JSXComponent { ... } TodoForm.STATE = { value: { value: '' } }; ","srcFilePath":"src/pages/docs/tutorials/tutorial-todo-jsx/configurating-state.md","id":"configurating-state","location":"/docs/tutorials/tutorial-todo-jsx/configurating-state.html","url":"/docs/tutorials/tutorial-todo-jsx/configurating-state.html"},"dependencies":{"title":"Dependencies","description":"Installing dependencies of Metal.js.","buttonTitle":"I installed the dependencies","parentId":"tutorial-todo-jsx","layout":"tutorial","time":90,"weight":2,"content":" {$page.title} To follow along with this tutorial you'll need Git and a recent version of Node.js/npm. Todo Boilerplate Start by cloning the boilerplate repository: git clone https://github.com/metal/metal-tutorial-todo.git Then navigate to the root of the project in your terminal and install the local npm dependencies: cd metal-tutorial-todo && npm install The boilerplate that you'll build on is located in the src/jsx directory. You can also view the finished product in the src/jsx/final directory. Building To test drive the boilerplate located in the src/jsx directory, run the build script shown below: npm run build:jsx This runs babel + webpack to transpile and bundle the JavaScript into something consumable by web browsers. This tutorial uses ES6 syntax; if you're unfamiliar with it, check out this guide first. To build the finished product, run the following script: npm run build:jsx:final Demo Now that you've built the project, go ahead and open the demo page located at demos/index.html. If you check the file you'll see that the component is already being invoked: new metal.TodoApp(); When you invoke a component this way, it is rendered to the body element. ","srcFilePath":"src/pages/docs/tutorials/tutorial-todo-jsx/dependencies.md","id":"dependencies","location":"/docs/tutorials/tutorial-todo-jsx/dependencies.html","url":"/docs/tutorials/tutorial-todo-jsx/dependencies.html"},"event-listeners":{"title":"Event Listeners","description":"Foo bar.","buttonTitle":"I added the event listeners","parentId":"tutorial-todo-jsx","layout":"tutorial","time":90,"weight":6,"content":" {$page.title} Now you should have a static list of todo items. What now? Remember the end goal is to be able to click the todos to mark them as completed, so let's start with adding a click event listener to the list items: // TodoItem.js class TodoItem extends JSXComponent { render() { const elementClasses = `todo-item${this.props.todo.done ? ' todo-item-done' : ''}`; return ( {this.props.todo.title} ); } handleClick(event) { alert(this.props.todo.title); } } Notice that the handleClick method has been bound to this. This is because you'll need to access instance properties inside the function. However, any JavaScript function can be passed as a handler, it doesn't have to be a method of the current class. Now you should see an alert with the title of the clicked todo. Next you must notify TodoApp that a todo was marked as completed so that it can update the data. This can be done by emitting a custom event with the info needed to make the change. In this case we'll use the index value from PROPS: // TodoItem.js class TodoItem extends JSXComponent { ... handleClick(event) { this.emit('todoClick', { index: this.props.index }); } } Now that the TodoItem is emitting an event, you must add a listener from the parent component TodoApp: // TodoApp.js class TodoApp extends JSXComponent { render() { return ( {this.state.todos.map((todo, index) = { return ( ); })} ); } handleTodoClick(event) { alert(event.index); } } At this point you should have an event handler that fires every time a todo item is clicked. Next you will use this data to update the state in TodoApp. Alternative to custom events Alternatively, you can pass functions from parents to children to achieve similar functionality. To do this, a child must declare a PROP to house the function from the parent: class Parent extends JSXComponent { render() { return ( ); } handleChange(event) { // Logic } } class Child extends JSXComponent { ... someMethod() { this.props.onChange({ // Payload }); } } Child.PROPS = { onChange: { } } `","srcFilePath":"src/pages/docs/tutorials/tutorial-todo-jsx/event-listeners.md","id":"event-listeners","location":"/docs/tutorials/tutorial-todo-jsx/event-listeners.html","url":"/docs/tutorials/tutorial-todo-jsx/event-listeners.html"},"rendering-data":{"title":"Rendering Data","description":"Foo bar.","buttonTitle":"I rendered the todo items","parentId":"tutorial-todo-jsx","layout":"tutorial","time":90,"weight":5,"content":" {$page.title} First, let's prepare the TodoItem for consuming the data passed from TodoApp: // TodoItem.js class TodoItem extends JSXComponent { render() { // Conditionally adding the 'todo-item-done' class if // the todo is done const elementClasses = `todo-item${this.props.todo.done ? ' todo-item-done' : ''}`; return ( {this.props.todo.title} ); } } Now that you have some data that needs rendering and the TodoItem is ready to consume it, you need to iterate over the todos and pass them to the child components: // TodoApp.js class TodoApp extends JSXComponent { render() { return ( {this.state.todos.map((todo, index) = { return ( ); })} ); } } This results in the following markup: Todo 1 Todo 2 ","srcFilePath":"src/pages/docs/tutorials/tutorial-todo-jsx/rendering-data.md","id":"rendering-data","location":"/docs/tutorials/tutorial-todo-jsx/rendering-data.html","url":"/docs/tutorials/tutorial-todo-jsx/rendering-data.html"},"updating-state":{"title":"Updating State","description":"Foo bar.","buttonTitle":"I updated the state","parentId":"tutorial-todo-jsx","layout":"tutorial","time":90,"weight":7,"content":" {$page.title} Now you're ready to update the state in TodoApp. In the last step, you added an event listener: // TodoApp.js class TodoApp extends JSXComponent { ... handleTodoClick(event) { alert(event.index); } } Now all you need to do is update the state so that the template rerenders: // TodoApp.js class TodoApp extends JSXComponent { ... handleTodoClick(event) { this.toggleTodo(event.index); } toggleTodo(clickedIndex) { this.state.todos = this.state.todos.map((todo, index) = { if (clickedIndex === index) { todo.done = !todo.done; } return todo; }); } } This toggles the done property of the todo that was clicked. Simply setting the this.state.todos property to a new array of todos triggers a rerender, passing the data to the child components. Your markup should look like this once you've clicked a todo item: Todo 1 Todo 2 ","srcFilePath":"src/pages/docs/tutorials/tutorial-todo-jsx/updating-state.md","id":"updating-state","location":"/docs/tutorials/tutorial-todo-jsx/updating-state.html","url":"/docs/tutorials/tutorial-todo-jsx/updating-state.html"}},"title":"Todo App: JSX","description":"Learn to create a simple Todo App with Metal.js and JSX.","icon":"menu","tutorialTitle":"Learn to create a simple Todo App with Metal.js and JSX","url":"/docs/tutorials/tutorial-todo-jsx/before-we-start.html","content":" ","srcFilePath":"src/pages/docs/tutorials/tutorial-todo-jsx/index.soy","id":"tutorial-todo-jsx","location":"/docs/tutorials/tutorial-todo-jsx/","customURL":true,"childIds":["before-we-start","dependencies","components","configurating-state","rendering-data","event-listeners","updating-state","adding-todos"]}},"childIds":["tutorial-todo-jsx","tutorial-todo-soy"]}},"childIds":["tutorials","guides","search"]}},"childIds":["docs"]}}